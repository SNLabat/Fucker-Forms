<!DOCTYPE html>
<html>
<head>
  <title>Spreadsheet Viewer (Web)</title>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <!-- React / ReactDOM -->
  <script src="https://unpkg.com/react@17/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
  <!-- Babel for in-browser transpiling (not recommended for production, but fine for demos) -->
  <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
  <!-- PapaParse for CSV -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
  <!-- xlsx library -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>

  <style>
    body {
      background-color: #1a1a1a;
      color: #ffffff;
      margin: 0;
      padding: 20px;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
    }
    .container {
      background-color: #2d2d2d;
      padding: 20px;
      border-radius: 8px;
    }
    .table-container {
      max-height: 600px;
      overflow-y: auto;
      margin-top: 20px;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      background-color: #2d2d2d;
    }
    th {
      background-color: #404040;
      padding: 12px;
      text-align: left;
      cursor: pointer;
    }
    td {
      padding: 12px;
      border-bottom: 1px solid #404040;
    }
    .row-green {
      background-color: rgba(144, 238, 144, 0.2);
    }
    .row-yellow {
      background-color: rgba(255, 255, 224, 0.2);
    }
    .row-red {
      background-color: rgba(255, 182, 182, 0.2);
    }
    input[type="file"] {
      background-color: #404040;
      padding: 10px;
      border-radius: 4px;
      border: none;
      color: white;
      margin-bottom: 20px;
    }
    input[type="text"] {
      background-color: #404040;
      border: 1px solid #555;
      color: white;
      padding: 8px;
      border-radius: 4px;
      margin: 5px;
    }
    button {
      background-color: #404040;
      color: white;
      border: none;
      padding: 6px 12px;
      margin: 0 4px;
      border-radius: 4px;
      cursor: pointer;
    }
    .header-controls {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }
    .save-button {
      background-color: #4CAF50;
      color: white;
      padding: 10px 20px;
      border-radius: 4px;
      cursor: pointer;
    }
    .save-button:hover {
      background-color: #45a049;
    }
    .save-button:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
    }
    .filters {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
      flex-wrap: wrap;
    }
    input[type="number"] {
      background-color: #404040;
      border: 1px solid #555;
      color: white;
      padding: 4px 8px;
      border-radius: 4px;
    }
    input[type="number"]:focus {
      outline: none;
      border-color: #666;
    }
    input[type="number"]::-webkit-inner-spin-button,
    input[type="number"]::-webkit-outer-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <!-- Your React code -->
  <script type="text/babel">

    const { useState, useMemo } = React;

    // We'll grab XLSX from the global scope (from the <script src="xlsx.full.min.js"> above).
    // Same for Papa (PapaParse).
    const XLSXLib = window.XLSX;
    const PapaLib = window.Papa;

    function App() {
      const [data, setData] = useState([]);
      const [columns, setColumns] = useState([]);
      const [sortConfig, setSortConfig] = useState({ key: null, direction: 'asc' });
      const [filters, setFilters] = useState({});
      const [rowColors, setRowColors] = useState({});
      const [sortDirection, setSortDirection] = useState('asc');

      // If your data doesn't have "salary" or "contributed" columns, 
      // you'll need to rename columns or adapt the logic accordingly.
      const handleFileUpload = (event) => {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();

        reader.onload = (e) => {
          const content = e.target.result;
          // If it's CSV
          if (file.name.endsWith('.csv')) {
            PapaLib.parse(content, {
              header: true,
              complete: (results) => {
                const dataWithUniqueKeys = results.data.map((row, index) => ({
                  ...row,
                  _uniqueKey: `row-${Date.now()}-${index}`,
                  rowColor: '',    // Default color column
                  contributed: row.contributed || '' // Ensure we have a contributed field
                }));
                setData(dataWithUniqueKeys);

                // Collect columns from meta fields, plus ensure "rowColor" and "contributed"
                const fields = results.meta.fields || [];
                const extraCols = ['rowColor', 'contributed'].filter(col => !fields.includes(col));
                setColumns([...fields, ...extraCols]);
              }
            });
          }
          // If it's XLSX
          else if (file.name.endsWith('.xlsx')) {
            const workbook = XLSXLib.read(content, { type: 'binary' });
            const sheetName = workbook.SheetNames[0];
            const sheet = workbook.Sheets[sheetName];
            const jsonData = XLSXLib.utils.sheet_to_json(sheet);

            const dataWithUniqueKeys = jsonData.map((row, index) => ({
              ...row,
              _uniqueKey: `row-${Date.now()}-${index}`,
              rowColor: row.rowColor || '',
              contributed: row.contributed || ''
            }));

            setData(dataWithUniqueKeys);

            const baseColumns = Object.keys(jsonData[0] || []);
            const extraCols = ['rowColor', 'contributed'].filter(col => !baseColumns.includes(col));
            setColumns([...baseColumns, ...extraCols]);
          }
        };

        // For CSV vs XLSX, read differently
        if (file.name.endsWith('.csv')) {
          reader.readAsText(file);
        } else {
          reader.readAsBinaryString(file);
        }
      };

      // Automatic color logic:
      //  1) If salary < contribution => green
      //  2) If contribution < salary/2 => red
      //  3) else => yellow
      const computeAutoColor = (row) => {
        const salary = parseFloat(row.salary) || 0;
        const contribution = parseFloat(row.contributed) || 0;

        if (contribution > salary) {
          return 'green';
        } else if (contribution < salary / 2) {
          return 'red';
        } else {
          return 'yellow';
        }
      };

      // We keep a manual color override too:
      const getRowColor = (row) => {
        // If there's a manually set color for this row, use that;
        // else use the auto-generated color from the logic above.
        return rowColors[row._uniqueKey] || computeAutoColor(row);
      };

      const handleRowColor = (uniqueKey, color) => {
        setRowColors((prev) => ({
          ...prev,
          [uniqueKey]: color
        }));
      };

      const handleContributedChange = (uniqueKey, value) => {
        setData((prevData) =>
          prevData.map((row) =>
            row._uniqueKey === uniqueKey
              ? { ...row, contributed: value }
              : row
          )
        );
      };

      const handleFilter = (column, value) => {
        setFilters((prev) => ({
          ...prev,
          [column]: value
        }));
      };

      const handleAmountSort = () => {
        // Toggle direction
        setSortDirection((prev) => (prev === 'asc' ? 'desc' : 'asc'));
        setSortConfig({ key: 'amount', direction: sortDirection });
      };

      // Optional: handle sort on any column, not just "amount"
      const handleSort = (column) => {
        if (sortConfig.key === column) {
          setSortConfig({
            key: column,
            direction: sortConfig.direction === 'asc' ? 'desc' : 'asc'
          });
        } else {
          setSortConfig({ key: column, direction: 'asc' });
        }
      };

      const filteredAndSortedData = useMemo(() => {
        let processedData = [...data];

        // Apply filters
        Object.keys(filters).forEach((column) => {
          const filterValue = (filters[column] || '').toLowerCase();
          if (filterValue) {
            processedData = processedData.filter((row) =>
              String(row[column] || '').toLowerCase().includes(filterValue)
            );
          }
        });

        // Apply sorting if it's the "amount" column
        if (sortConfig.key === 'amount') {
          processedData.sort((a, b) => {
            const aValue = parseFloat(a.amount) || 0;
            const bValue = parseFloat(b.amount) || 0;
            return sortConfig.direction === 'asc' ? aValue - bValue : bValue - aValue;
          });
        }
        // Or if you want to apply sorting on the "salary" column, or any other column, you can adapt similarly.

        return processedData;
      }, [data, sortConfig, filters]);

      // Helper: convert workbook output to array buffer
      function s2ab(s) {
        const buf = new ArrayBuffer(s.length);
        const view = new Uint8Array(buf);
        for (let i = 0; i < s.length; i++) {
          view[i] = s.charCodeAt(i) & 0xFF;
        }
        return buf;
      }

      // Save the current data to an XLSX, in-browser.
      const handleSave = () => {
        if (!filteredAndSortedData.length) return;

        // Build array of rows with color and contributed
        const dataToSave = filteredAndSortedData.map((row) => {
          const newRow = { ...row };
          // Keep rowColor & contributed, remove _uniqueKey
          delete newRow._uniqueKey;
          return newRow;
        });

        try {
          // New workbook
          const wb = XLSXLib.utils.book_new();
          const ws = XLSXLib.utils.json_to_sheet(dataToSave);

          // Apply styling, including row highlight colors
          filteredAndSortedData.forEach((row, idx) => {
            const autoOrManualColor = getRowColor(row);

            const colorMap = {
              green: {
                patternType: 'solid',
                fgColor: { rgb: '90EE90' },
                bgColor: { rgb: '90EE90' }
              },
              yellow: {
                patternType: 'solid',
                fgColor: { rgb: 'FFFFE0' },
                bgColor: { rgb: 'FFFFE0' }
              },
              red: {
                patternType: 'solid',
                fgColor: { rgb: 'FFB6B6' },
                bgColor: { rgb: 'FFB6B6' }
              }
            };
            const style = colorMap[autoOrManualColor];
            if (style) {
              // For each column, apply the style
              columns.forEach((col, colIndex) => {
                const cellRef = XLSXLib.utils.encode_cell({ r: idx + 1, c: colIndex });
                if (!ws[cellRef]) ws[cellRef] = {};
                ws[cellRef].s = {
                  fill: style,
                  border: {
                    top: { style: 'thin', color: { auto: 1 } },
                    bottom: { style: 'thin', color: { auto: 1 } },
                    left: { style: 'thin', color: { auto: 1 } },
                    right: { style: 'thin', color: { auto: 1 } }
                  }
                };
              });
            }
          });

          // Column widths
          const colWidths = columns.map((col) => ({
            wch: col === 'contributed' ? 15 : Math.max(col.length, 10)
          }));
          ws['!cols'] = colWidths;

          // Append sheet
          XLSXLib.utils.book_append_sheet(wb, ws, 'Sheet1');

          // Write workbook to a binary string
          const wbout = XLSXLib.write(wb, {
            bookType: 'xlsx',
            type: 'binary',
            cellStyles: true,
          });

          // Convert to Blob and trigger download
          const blob = new Blob([s2ab(wbout)], { type: 'application/octet-stream' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = 'exported_data.xlsx';
          a.click();
          URL.revokeObjectURL(url);

        } catch (error) {
          console.error('Error preparing file:', error);
          alert('Error preparing file. Check console for details.');
        }
      };

      return (
        <div className="container">
          <div className="header-controls">
            <input type="file" accept=".csv,.xlsx" onChange={handleFileUpload} />
            <button
              className="save-button"
              onClick={handleSave}
              disabled={data.length === 0}
            >
              Save Current View
            </button>
          </div>

          <div className="filters-and-sort">
            <div className="filters">
              {['action', 'description', 'done_at', 'salary'].map(column => (
                columns.includes(column) && (
                  <div key={column}>
                    <label>{column}: </label>
                    <input
                      type="text"
                      onChange={(e) => handleFilter(column, e.target.value)}
                      placeholder={`Filter ${column}...`}
                    />
                  </div>
                )
              ))}
            </div>

            {/* Sort button example if 'amount' is present */}
            <button
              className="sort-button"
              onClick={handleAmountSort}
              disabled={!columns.includes('amount')}
            >
              Sort Amount {sortDirection === 'asc' ? '↑' : '↓'}
            </button>
          </div>

          <div className="table-container">
            <table>
              <thead>
                <tr>
                  <th>Row Actions</th>
                  {columns.map((column) => (
                    <th
                      key={column}
                      onClick={() => handleSort(column)}
                    >
                      {column}
                      {sortConfig.key === column && (
                        sortConfig.direction === 'asc' ? ' ↑' : ' ↓'
                      )}
                    </th>
                  ))}
                </tr>
              </thead>
              <tbody>
                {filteredAndSortedData.map((row) => {
                  // Evaluate color by the auto logic + manual override
                  const rowHighlight = getRowColor(row);
                  return (
                    <tr
                      key={row._uniqueKey}
                      className={`row-${rowHighlight}`}
                    >
                      <td>
                        {/* Manual overrides - remove if you only want auto-color */}
                        <button onClick={() => handleRowColor(row._uniqueKey, 'green')}>Green</button>
                        <button onClick={() => handleRowColor(row._uniqueKey, 'yellow')}>Yellow</button>
                        <button onClick={() => handleRowColor(row._uniqueKey, 'red')}>Red</button>
                        <button onClick={() => handleRowColor(row._uniqueKey, '')}>Auto</button>
                      </td>
                      {columns.map((column) => {
                        if (column === 'rowColor') {
                          // You can hide or display the rowColor column if you want
                          return (
                            <td key={column}>
                              {row.rowColor || ''}
                            </td>
                          );
                        }
                        if (column === 'contributed') {
                          // An editable numeric field for user input
                          return (
                            <td key={column}>
                              <input
                                type="number"
                                value={row.contributed || ''}
                                onChange={(e) => handleContributedChange(row._uniqueKey, e.target.value)}
                                style={{
                                  width: '100px',
                                  padding: '4px',
                                  backgroundColor: '#404040',
                                  border: '1px solid #555',
                                  color: 'white'
                                }}
                              />
                            </td>
                          );
                        }
                        return (
                          <td key={column}>
                            {row[column]}
                          </td>
                        );
                      })}
                    </tr>
                  );
                })}
              </tbody>
            </table>
          </div>
        </div>
      );
    }

    ReactDOM.render(<App />, document.getElementById('root'));
  </script>
</body>
</html>
