<!DOCTYPE html>
<html>
<head>
  <title>Fucker Forms</title>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <!-- React / ReactDOM -->
  <script src="https://unpkg.com/react@17/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
  <!-- Babel for in-browser transpiling (not recommended for production, but fine for demos) -->
  <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
  <!-- PapaParse for CSV -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
  <!-- xlsx library -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>

  <style>
    body {
      background-color: #1a1a1a;
      color: #ffffff;
      margin: 0;
      padding: 20px;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
    }
    .container {
      background-color: #2d2d2d;
      padding: 20px;
      border-radius: 8px;
    }
    .table-container {
      max-height: 600px;
      overflow-y: auto;
      margin-top: 20px;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      background-color: #2d2d2d;
    }
    th {
      background-color: #404040;
      padding: 12px;
      text-align: left;
      cursor: pointer;
    }
    td {
      padding: 12px;
      border-bottom: 1px solid #404040;
    }
    /* Color-coded row classes */
    .row-green {
      background-color: rgba(144, 238, 144, 0.2);
    }
    .row-yellow {
      background-color: rgba(255, 255, 224, 0.2);
    }
    .row-red {
      background-color: rgba(255, 182, 182, 0.2);
    }
    input[type="file"] {
      background-color: #404040;
      padding: 10px;
      border-radius: 4px;
      border: none;
      color: white;
      margin-bottom: 20px;
    }
    input[type="text"], input[type="number"] {
      background-color: #404040;
      border: 1px solid #555;
      color: white;
      padding: 8px;
      border-radius: 4px;
      margin: 5px;
    }
    button {
      background-color: #404040;
      color: white;
      border: none;
      padding: 6px 12px;
      margin: 0 4px;
      border-radius: 4px;
      cursor: pointer;
    }
    .header-controls {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }
    .save-button {
      background-color: #4CAF50;
      color: white;
      padding: 10px 20px;
      border-radius: 4px;
      cursor: pointer;
    }
    .save-button:hover {
      background-color: #45a049;
    }
    .save-button:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
    }
    .filters {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
      flex-wrap: wrap;
    }
    input[type="number"]:focus {
      outline: none;
      border-color: #666;
    }
    input[type="number"]::-webkit-inner-spin-button,
    input[type="number"]::-webkit-outer-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }
    /* Instructions styling */
    .instructions {
      background-color: #202020;
      margin-top: 20px;
      padding: 20px;
      border-radius: 8px;
      max-width: 600px;
    }
    .instructions h2 {
      margin-top: 0;
    }
    .instructions ol {
      margin: 10px 0;
      padding-left: 20px;
    }
    /* Error box styling */
    .error-box {
      background-color: #660000;
      color: #ffffff;
      margin-top: 20px;
      padding: 20px;
      border-radius: 8px;
      max-width: 700px;
      word-wrap: break-word; /* wrap long error messages */
    }
    .error-box h2 {
      margin-top: 0;
      color: #ff8080;
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useMemo } = React;
    const XLSXLib = window.XLSX;
    const PapaLib = window.Papa;

    function App() {
      const [data, setData] = useState([]);
      const [columns, setColumns] = useState([]);
      const [sortConfig, setSortConfig] = useState({ key: null, direction: 'asc' });
      const [filters, setFilters] = useState({});
      const [rowColors, setRowColors] = useState({});
      const [sortDirection, setSortDirection] = useState('asc');
      const [errorMessage, setErrorMessage] = useState('');

      // We'll unify "amount" and "description" ignoring case
      // Then store them in row.amount & row.description
      // The user can then filter/sort by "amount" or "description".

      function resetState() {
        setData([]);
        setColumns([]);
        setRowColors({});
        setFilters({});
        setSortConfig({ key: null, direction: 'asc' });
      }

      // We require "amount" (any case). "description" is not strictly required, 
      // but if it’s present, we unify it. 
      function hasValidData() {
        // Must have a column "amount"
        return columns.includes('amount') && data.length > 0;
      }

      function showError(msg) {
        setErrorMessage(msg);
      }
      function clearError() {
        setErrorMessage('');
      }

      const handleFileUpload = (e) => {
        const file = e.target.files[0];
        if (!file) {
          showError('No file selected.');
          return;
        }

        resetState();
        clearError();

        try {
          const reader = new FileReader();
          reader.onload = (ev) => {
            const content = ev.target.result;
            try {
              if (file.name.toLowerCase().endsWith('.csv')) {
                parseCSV(content);
              } else if (file.name.toLowerCase().endsWith('.xlsx')) {
                parseXLSX(content);
              } else {
                showError('Unsupported file type. Please upload a .csv or .xlsx file.');
              }
            } catch (parseErr) {
              showError(`Error parsing file: ${parseErr.message}`);
            }
          };

          if (file.name.toLowerCase().endsWith('.csv')) {
            reader.readAsText(file);
          } else {
            reader.readAsBinaryString(file);
          }
        } catch (err) {
          showError(`Failed to read file: ${err.message}`);
        }
      };

      // unifyCaseInRow => renames any "Amount"/"AMOUNT"/etc -> row.amount
      // and any "description"/"DESCRIPTION" -> row.description
      function unifyCaseInRow(row) {
        // For amount
        const amtKey = Object.keys(row).find(k => k.toLowerCase() === 'amount');
        if (amtKey && amtKey !== 'amount') {
          row.amount = row[amtKey];
          delete row[amtKey];
        }
        // For description
        const descKey = Object.keys(row).find(k => k.toLowerCase() === 'description');
        if (descKey && descKey !== 'description') {
          row.description = row[descKey];
          delete row[descKey];
        }
        return row;
      }

      // unifyCaseInColumns => "Amount"/"AMOUNT" => "amount", "description"/"Description" => "description"
      function unifyCaseInColumns(colList) {
        return colList.map(col => {
          const lower = col.toLowerCase();
          if (lower === 'amount') {
            return 'amount';
          } else if (lower === 'description') {
            return 'description';
          }
          return col;
        });
      }

      // CSV parse
      function parseCSV(content) {
        PapaLib.parse(content, {
          header: true,
          complete: (results) => {
            const rowsRaw = results.data;
            let fields = results.meta.fields || [];

            if (!rowsRaw || rowsRaw.length === 0) {
              showError('Error: CSV is empty. Please check your file.');
              return;
            }

            // unify column names
            fields = unifyCaseInColumns(fields);

            // Must have "amount" after unifying
            if (!fields.includes('amount')) {
              showError('Error: Required column "amount" (any case) is missing in CSV.');
              return;
            }

            // Ensure difference, contributed, rowColor
            if (!fields.includes('difference')) fields.push('difference');
            if (!fields.includes('contributed')) fields.push('contributed');
            if (!fields.includes('rowColor')) fields.push('rowColor');
            // If "description" was found in some case, it’s now "description" in fields

            // unify each row, compute difference
            const finalRows = rowsRaw.map((rawRow, idx) => {
              const row = unifyCaseInRow({ ...rawRow });
              const amountNum = parseFloat(sanitizeNumberString(row.amount)) || 0;
              const contribNum = parseFloat(sanitizeNumberString(row.contributed)) || 0;
              const diff = contribNum - amountNum;
              return {
                ...row,
                _uniqueKey: `row-${Date.now()}-${idx}`,
                contributed: row.contributed || '',
                rowColor: row.rowColor || '',
                difference: diff.toString()
              };
            });

            setData(finalRows);
            setColumns(fields);
          },
          error: (err) => {
            showError(`PapaParse error: ${err.message}`);
          }
        });
      }

      // XLSX parse
      function parseXLSX(content) {
        try {
          const workbook = XLSXLib.read(content, { type: 'binary' });
          if (!workbook.SheetNames || workbook.SheetNames.length === 0) {
            showError('Error: This Excel file has no sheets. Please check your file.');
            return;
          }

          const sheetName = workbook.SheetNames[0];
          const sheet = workbook.Sheets[sheetName];
          const jsonData = XLSXLib.utils.sheet_to_json(sheet);
          if (!jsonData || jsonData.length === 0) {
            showError('Error: The first sheet of this Excel file is empty. Please check your file.');
            return;
          }

          // unify columns from the first row
          let baseCols = Object.keys(jsonData[0]);
          baseCols = unifyCaseInColumns(baseCols);

          if (!baseCols.includes('amount')) {
            showError('Error: Required column "amount" (any case) is missing in Excel.');
            return;
          }

          if (!baseCols.includes('difference')) baseCols.push('difference');
          if (!baseCols.includes('contributed')) baseCols.push('contributed');
          if (!baseCols.includes('rowColor')) baseCols.push('rowColor');

          const finalRows = jsonData.map((rawRow, idx) => {
            const row = unifyCaseInRow({ ...rawRow });
            const amountNum = parseFloat(sanitizeNumberString(row.amount)) || 0;
            const contribNum = parseFloat(sanitizeNumberString(row.contributed)) || 0;
            const diff = contribNum - amountNum;
            return {
              ...row,
              _uniqueKey: `row-${Date.now()}-${idx}`,
              contributed: row.contributed || '',
              rowColor: row.rowColor || '',
              difference: diff.toString()
            };
          });

          setData(finalRows);
          setColumns(baseCols);
        } catch (err) {
          showError(`Error reading XLSX: ${err.message}`);
        }
      }

      // sanitize input for parseFloat
      function sanitizeNumberString(val) {
        if (val === null || val === undefined) return '';
        const str = String(val);
        return str.replace(/[^\d.-]/g, '');
      }

      function computeAutoColor(row) {
        try {
          if (!hasValidData()) return '';
          const amtStr = sanitizeNumberString(row.amount || '');
          const contrStr = sanitizeNumberString(row.contributed || '');
          if (!amtStr || !contrStr) return '';
          const amount = parseFloat(amtStr) || 0;
          const contributed = parseFloat(contrStr) || 0;
          if (amount === 0 && contributed === 0) return '';
          if (contributed > amount) return 'green';
          if (contributed < amount / 2) return 'red';
          return 'yellow';
        } catch (err) {
          showError(`Error computing color: ${err.message}`);
          return '';
        }
      }

      function handleContributedChange(uniqueKey, newVal) {
        if (!hasValidData()) {
          showError('No valid data loaded. Please upload a valid sheet with "amount" column.');
          return;
        }
        try {
          setData(prev => prev.map(row => {
            if (row._uniqueKey === uniqueKey) {
              const amountNum = parseFloat(sanitizeNumberString(row.amount)) || 0;
              const contribNum = parseFloat(sanitizeNumberString(newVal)) || 0;
              const diff = contribNum - amountNum;
              const manual = rowColors[uniqueKey];
              const updated = {
                ...row,
                contributed: newVal,
                difference: diff.toString()
              };
              updated.rowColor = manual || computeAutoColor(updated);
              return updated;
            }
            return row;
          }));
        } catch (err) {
          showError(`Error updating contributed: ${err.message}`);
        }
      }

      function handleRowColor(uniqueKey, color) {
        if (!hasValidData()) {
          showError('No valid data loaded. Please upload a valid sheet with "amount" column.');
          return;
        }
        try {
          setRowColors(prev => ({ ...prev, [uniqueKey]: color }));
          setData(prev => prev.map(row => {
            if (row._uniqueKey === uniqueKey) {
              if (!color) {
                // revert to auto
                const auto = computeAutoColor(row);
                return { ...row, rowColor: auto };
              }
              return { ...row, rowColor: color };
            }
            return row;
          }));
        } catch (err) {
          showError(`Error overriding color: ${err.message}`);
        }
      }

      function handleFilter(column, value) {
        try {
          setFilters(prev => ({ ...prev, [column]: value }));
        } catch (err) {
          showError(`Error filtering data: ${err.message}`);
        }
      }

      function handleAmountSort() {
        if (!hasValidData()) {
          showError('No valid data loaded or missing "amount" column. Cannot sort.');
          return;
        }
        try {
          setSortDirection(prev => (prev === 'asc' ? 'desc' : 'asc'));
          setSortConfig({ key: 'amount', direction: sortDirection });
        } catch (err) {
          showError(`Error sorting by amount: ${err.message}`);
        }
      }

      function handleSort(col) {
        if (!hasValidData()) {
          showError('No valid data loaded. Cannot sort.');
          return;
        }
        try {
          if (sortConfig.key === col) {
            setSortConfig({
              key: col,
              direction: sortConfig.direction === 'asc' ? 'desc' : 'asc'
            });
          } else {
            setSortConfig({ key: col, direction: 'asc' });
          }
        } catch (err) {
          showError(`Error sorting: ${err.message}`);
        }
      }

      const filteredAndSortedData = useMemo(() => {
        if (!hasValidData()) return [];

        try {
          let processed = [...data];
          Object.keys(filters).forEach(col => {
            const val = (filters[col] || '').toLowerCase();
            if (val) {
              processed = processed.filter(row =>
                String(row[col] || '').toLowerCase().includes(val)
              );
            }
          });

          if (sortConfig.key === 'amount') {
            processed.sort((a, b) => {
              const aVal = parseFloat(sanitizeNumberString(a.amount || '')) || 0;
              const bVal = parseFloat(sanitizeNumberString(b.amount || '')) || 0;
              return sortConfig.direction === 'asc' ? aVal - bVal : bVal - aVal;
            });
          }
          return processed;
        } catch (err) {
          showError(`Error processing data: ${err.message}`);
          return [];
        }
      }, [data, filters, sortConfig]);

      function s2ab(s) {
        const buf = new ArrayBuffer(s.length);
        const view = new Uint8Array(buf);
        for (let i = 0; i < s.length; i++) {
          view[i] = s.charCodeAt(i) & 0xFF;
        }
        return buf;
      }

      function handleSave() {
        if (!hasValidData() || !filteredAndSortedData.length) {
          showError('No valid data to save. Please upload a sheet with the "amount" column and try again.');
          return;
        }
        try {
          const dataToSave = filteredAndSortedData.map(row => {
            const newRow = { ...row };
            delete newRow._uniqueKey;
            return newRow;
          });

          const wb = XLSXLib.utils.book_new();
          const ws = XLSXLib.utils.json_to_sheet(dataToSave);

          // Color styling
          filteredAndSortedData.forEach((row, idx) => {
            const colorName = row.rowColor || '';
            if (!colorName) return;

            const colorMap = {
              green: {
                patternType: 'solid',
                fgColor: { rgb: '90EE90' },
                bgColor: { rgb: '90EE90' }
              },
              yellow: {
                patternType: 'solid',
                fgColor: { rgb: 'FFFFE0' },
                bgColor: { rgb: 'FFFFE0' }
              },
              red: {
                patternType: 'solid',
                fgColor: { rgb: 'FFB6B6' },
                bgColor: { rgb: 'FFB6B6' }
              }
            };
            const style = colorMap[colorName];
            if (!style) return;

            columns.forEach((col, colIndex) => {
              const cellRef = XLSXLib.utils.encode_cell({ r: idx + 1, c: colIndex });
              if (!ws[cellRef]) ws[cellRef] = {};
              ws[cellRef].s = {
                fill: style,
                border: {
                  top: { style: 'thin', color: { auto: 1 } },
                  bottom: { style: 'thin', color: { auto: 1 } },
                  left: { style: 'thin', color: { auto: 1 } },
                  right: { style: 'thin', color: { auto: 1 } }
                }
              };
            });
          });

          // Adjust column widths
          const colWidths = columns.map(col => ({
            wch: col === 'contributed' ? 15 : Math.max(col.length, 10)
          }));
          ws['!cols'] = colWidths;

          XLSXLib.utils.book_append_sheet(wb, ws, 'Sheet1');

          const wbout = XLSXLib.write(wb, {
            bookType: 'xlsx',
            type: 'binary',
            cellStyles: true
          });

          const blob = new Blob([s2ab(wbout)], { type: 'application/octet-stream' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = 'exported_data.xlsx';
          a.click();
          URL.revokeObjectURL(url);
        } catch (err) {
          showError(`Error preparing file for save: ${err.message}`);
        }
      }

      return (
        <div className="container">
          <div className="header-controls">
            <input type="file" accept=".csv,.xlsx" onChange={handleFileUpload} />
            <button
              className="save-button"
              onClick={handleSave}
              disabled={!hasValidData()}
            >
              Save Current View
            </button>
          </div>

          <div className="filters-and-sort">
            <div className="filters">
              {/* We can list potential columns, but only show if they're in "columns" after unifying */}
              {['description', 'amount', 'difference', 'contributed'].map(col => (
                columns.includes(col) && (
                  <div key={col}>
                    <label>{col}: </label>
                    <input
                      type="text"
                      onChange={e => handleFilter(col, e.target.value)}
                      placeholder={`Filter ${col}...`}
                      disabled={!hasValidData()}
                    />
                  </div>
                )
              ))}
            </div>
            <button
              className="sort-button"
              onClick={handleAmountSort}
              disabled={!columns.includes('amount') || !hasValidData()}
            >
              Sort Amount {sortDirection === 'asc' ? '↑' : '↓'}
            </button>
          </div>

          <div className="table-container">
            <table>
              <thead>
                <tr>
                  <th>Row Actions</th>
                  {columns.map(col => (
                    <th
                      key={col}
                      onClick={() => handleSort(col)}
                    >
                      {col}
                      {sortConfig.key === col && (
                        sortConfig.direction === 'asc' ? ' ↑' : ' ↓'
                      )}
                    </th>
                  ))}
                </tr>
              </thead>
              <tbody>
                {filteredAndSortedData.map(row => {
                  const highlightClass = row.rowColor ? `row-${row.rowColor}` : '';
                  return (
                    <tr key={row._uniqueKey} className={highlightClass}>
                      <td>
                        <button onClick={() => handleRowColor(row._uniqueKey, 'green')}>Green</button>
                        <button onClick={() => handleRowColor(row._uniqueKey, 'yellow')}>Yellow</button>
                        <button onClick={() => handleRowColor(row._uniqueKey, 'red')}>Red</button>
                        <button onClick={() => handleRowColor(row._uniqueKey, '')}>Auto</button>
                      </td>
                      {columns.map(col => {
                        if (col === 'rowColor') {
                          return <td key={col}>{row.rowColor}</td>;
                        }
                        if (col === 'contributed') {
                          return (
                            <td key={col}>
                              <input
                                type="text"
                                value={row.contributed || ''}
                                onChange={e => handleContributedChange(row._uniqueKey, e.target.value)}
                                style={{
                                  width: '100px',
                                  padding: '4px',
                                  backgroundColor: '#404040',
                                  border: '1px solid #555',
                                  color: 'white'
                                }}
                              />
                            </td>
                          );
                        }
                        return <td key={col}>{row[col]}</td>;
                      })}
                    </tr>
                  );
                })}
              </tbody>
            </table>
          </div>

          {/* Instructions Section */}
          <div className="instructions">
            <h2>Instructions:</h2>
            <ol>
              <li>
                Upload a CSV or XLSX with columns for <code>description</code> 
                and <code>amount</code> in any case (e.g. <code>DESCRIPTION</code>, 
                <code>AMOUNT</code>, etc.).
              </li>
              <li>
                The app will unify them to lowercase <code>description</code> 
                and <code>amount</code>.
              </li>
              <li>
                Filter or sort by <code>description</code>, <code>amount</code>, or
                other columns (e.g. <code>difference</code>, <code>contributed</code>).
              </li>
              <li>
                When you edit the <code>contributed</code> field, the row color
                recalculates automatically based on <code>amount</code>, and 
                a <code>difference</code> column shows <code>(contributed - amount)</code>.
              </li>
              <li>
                Manually override row colors with the buttons (Green/Yellow/Red/Auto).
              </li>
              <li>
                Click <strong>Save Current View</strong> to export to XLSX with 
                the coloring. 
              </li>
            </ol>
          </div>

          {/* Error Message Section (only visible if errorMessage is non-empty) */}
          {errorMessage && (
            <div className="error-box">
              <h2>Error</h2>
              <p>{errorMessage}</p>
            </div>
          )}
        </div>
      );
    }

    ReactDOM.render(<App />, document.getElementById('root'));
  </script>
</body>
</html>
